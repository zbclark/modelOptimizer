/**
 * PlayerRankingModelFormatter.bound.gs
 *
 * Purpose:
 * - Copy/paste this file into a Google Sheets *bound* Apps Script project.
 * - Adds an onOpen menu and applies formatting + conditional formatting rules
 *   to the "Player Ranking Model" tab using the schema generated by Node.
 *
 * Not a library:
 * - This is intentionally designed to live inside the spreadsheet itself.
 *
 * How to use:
 * 1) Paste the JSON contents of:
 *    apps-scripts/modelOptimizer/utilities/ranking_formatting_schema.json
 *    into RANKING_FORMATTING_SCHEMA_JSON below.
 * 2) Reload the spreadsheet.
 * 3) Use menu: Rankings → Format Player Ranking Model.
 */

/* ====== 1) Paste schema JSON here ====== */

// eslint-disable-next-line no-unused-vars
const RANKING_FORMATTING_SCHEMA_JSON = '';

/* ====== 2) Entry points ====== */

function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Rankings')
    .addItem('Rename active tab to Player Ranking Model', 'renameActiveSheetToPlayerRankingModel')
    .addItem('Format Player Ranking Model', 'formatPlayerRankingModelSheet')
    .addSeparator()
    .addItem('Format active sheet (advanced)', 'formatActiveSheetAsPlayerRankingModel')
    .addToUi();
}

function renameActiveSheetToPlayerRankingModel() {
  const schema = getSchema_();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const active = ss.getActiveSheet();

  if (active.getName() === schema.sheetName) return;

  const existing = ss.getSheetByName(schema.sheetName);
  if (existing && existing.getSheetId() !== active.getSheetId()) {
    throw new Error(`A sheet named "${schema.sheetName}" already exists. Rename or delete it first.`);
  }

  active.setName(schema.sheetName);
}

function formatPlayerRankingModelSheet() {
  const schema = getSchema_();
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  const sheet = ss.getSheetByName(schema.sheetName) || ss.getActiveSheet();
  if (sheet.getName() !== schema.sheetName) {
    // If user imported CSV into a random tab name, we can just rename it.
    sheet.setName(schema.sheetName);
  }

  formatSheet_(sheet, schema);
}

function formatActiveSheetAsPlayerRankingModel() {
  const schema = getSchema_();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();

  formatSheet_(sheet, schema);
}

/* ====== 3) Core formatting ====== */

function formatSheet_(sheet, schema) {
  const notesCol = schema.notesColumn;
  const startCol = schema.tableStartColumn;
  const headerRow = schema.headerRow;
  const medianRow = schema.medianRow;
  const dataStartRow = schema.dataStartRow;
  const cfStartRow = schema.conditionalFormattingStartRow || dataStartRow;

  const numCols = schema.columns.length;
  const endCol = startCol + numCols - 1;

  // Find where the table actually ends (based on non-empty Rank column values)
  const lastDataRow = findLastNonEmptyRowInColumn_(sheet, startCol, dataStartRow);
  const tableLastRow = Math.max(lastDataRow, medianRow);

  // Guard: if the sheet is basically empty, still apply column widths + header styling.
  const safeLastRow = Math.max(tableLastRow, headerRow);

  // Freeze header area
  sheet.setFrozenRows(headerRow);

  // Apply column widths
  sheet.setColumnWidth(notesCol, schema.notesColumnWidth || 350);
  schema.columns.forEach((col, i) => {
    const width = col.width || (schema.columnDefaults && schema.columnDefaults.width) || 110;
    sheet.setColumnWidth(startCol + i, width);
  });

  // Header style (A5:...5)
  const headerRange = sheet.getRange(headerRow, notesCol, 1, (endCol - notesCol + 1));
  headerRange
    .setFontWeight('bold')
    .setWrap(true)
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle')
    .setBackground('#f1f3f4');

  // Median row style (light blue) — across notes + all table columns
  const medianRange = sheet.getRange(medianRow, notesCol, 1, (endCol - notesCol + 1));
  medianRange
    .setBackground('#D2E3FC')
    .setFontWeight('bold')
    .setVerticalAlignment('middle');

  // Alignment: notes + player name left, most numeric centered
  // Notes column (A) for data area
  if (safeLastRow >= dataStartRow) {
    sheet.getRange(dataStartRow, notesCol, safeLastRow - dataStartRow + 1, 1)
      .setHorizontalAlignment('left')
      .setVerticalAlignment('middle')
      .setWrap(true);
  }

  // Player Name column is schema.columns index 2 (0-based), so sheet col = startCol + 2
  const playerNameCol = startCol + 2;
  if (safeLastRow >= dataStartRow) {
    sheet.getRange(dataStartRow, playerNameCol, safeLastRow - dataStartRow + 1, 1)
      .setHorizontalAlignment('left')
      .setVerticalAlignment('middle');
  }

  // Center everything else in the table area (excluding notes + player name)
  if (safeLastRow >= dataStartRow) {
    const leftBlockWidth = (playerNameCol - startCol); // cols from startCol..(playerNameCol-1)
    if (leftBlockWidth > 0) {
      sheet.getRange(dataStartRow, startCol, safeLastRow - dataStartRow + 1, leftBlockWidth)
        .setHorizontalAlignment('center')
        .setVerticalAlignment('middle');
    }

    const rightBlockStart = playerNameCol + 1;
    const rightBlockWidth = endCol - rightBlockStart + 1;
    if (rightBlockWidth > 0) {
      sheet.getRange(dataStartRow, rightBlockStart, safeLastRow - dataStartRow + 1, rightBlockWidth)
        .setHorizontalAlignment('center')
        .setVerticalAlignment('middle');
    }
  }

  // Coerce imported strings ("0.123", "12.3%") into numbers for numeric columns.
  // This is optional but strongly recommended for conditional formatting.
  coerceNumericColumns_(sheet, schema, medianRow, tableLastRow);

  // Apply number formats from schema (skip header row)
  schema.columns.forEach((col, i) => {
    const colIndex = startCol + i;
    const format = col.format || (schema.columnDefaults && schema.columnDefaults.format) || '0.000';

    // Do not format header row.
    if (tableLastRow >= medianRow) {
      sheet.getRange(medianRow, colIndex, tableLastRow - medianRow + 1, 1)
        .setNumberFormat(format === 'text' ? '@' : format);
    }
  });

  // Clear existing conditional formatting rules on the sheet (keeps it deterministic)
  sheet.setConditionalFormatRules([]);

  // Rebuild rules based on schema
  const rules = buildConditionalFormattingRules_(sheet, schema, cfStartRow, tableLastRow);
  sheet.setConditionalFormatRules(rules);
}

/* ====== 4) Conditional formatting rule builders ====== */

function buildConditionalFormattingRules_(sheet, schema, startRow, endRow) {
  if (endRow < startRow) return [];

  const startCol = schema.tableStartColumn;
  const numCols = schema.columns.length;

  const rules = [];

  // A) Grey for zero-as-no-data columns (ONLY where explicitly flagged)
  schema.columns.forEach((col, i) => {
    if (!col.zeroAsNoData) return;

    const sheetCol = startCol + i;
    const range = sheet.getRange(startRow, sheetCol, endRow - startRow + 1, 1);

    const cellA1 = a1_(startRow, sheetCol);
    const formula = `=AND(ISNUMBER(${cellA1}),${cellA1}=0)`;

    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(formula)
        .setBackground(schema.zScoreColoring && schema.zScoreColoring.zeroColor ? schema.zScoreColoring.zeroColor : '#D3D3D3')
        .setRanges([range])
        .build()
    );
  });

  // B) Z-score coloring (formula-based), excludes median row by using startRow
  // NOTE: This can create many rules. If this sheet gets sluggish, reduce thresholds or columns.
  const z = schema.zScoreColoring || {};
  const thresholds = z.thresholds || [0.5, 1, 2];
  const pos = z.positivePalette || ['#a1d99b', '#31a354', '#006837'];
  const neg = z.negativePalette || ['#fb6a4a', '#de2d26', '#a50f15'];

  const t1 = thresholds[0];
  const t2 = thresholds[1];
  const t3 = thresholds[2];

  schema.columns.forEach((col, i) => {
    if (!col.zScoreColoring) return;

    const sheetCol = startCol + i;
    const range = sheet.getRange(startRow, sheetCol, endRow - startRow + 1, 1);

    const firstCell = a1_(startRow, sheetCol);
    const colDataRange = `${colToLetter_(sheetCol)}${startRow}:${colToLetter_(sheetCol)}${endRow}`;

    // z = (x - avg) / stdev; invert sign for lower-is-better so "good" is always positive z.
    const rawZ = `IFERROR((${firstCell}-AVERAGE(${colDataRange}))/STDEV(${colDataRange}),0)`;
    const zAdj = col.direction === 'lower_better' ? `(-1*(${rawZ}))` : `(${rawZ})`;

    const valueGuard = col.zeroAsNoData
      ? `AND(ISNUMBER(${firstCell}),${firstCell}<>0)`
      : `ISNUMBER(${firstCell})`;

    // Positive thresholds
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(`=AND(${valueGuard},${zAdj}>=${t3})`)
        .setBackground(pos[2])
        .setRanges([range])
        .build()
    );
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(`=AND(${valueGuard},${zAdj}>=${t2},${zAdj}<${t3})`)
        .setBackground(pos[1])
        .setRanges([range])
        .build()
    );
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(`=AND(${valueGuard},${zAdj}>=${t1},${zAdj}<${t2})`)
        .setBackground(pos[0])
        .setRanges([range])
        .build()
    );

    // Negative thresholds
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(`=AND(${valueGuard},${zAdj}<=-${t3})`)
        .setBackground(neg[2])
        .setRanges([range])
        .build()
    );
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(`=AND(${valueGuard},${zAdj}<=-${t2},${zAdj}>-${t3})`)
        .setBackground(neg[1])
        .setRanges([range])
        .build()
    );
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(`=AND(${valueGuard},${zAdj}<=-${t1},${zAdj}>-${t2})`)
        .setBackground(neg[0])
        .setRanges([range])
        .build()
    );
  });

  // C) Trend formatting (light green/red) for trend columns
  const trendCfg = schema.trendFormatting || {};
  const bgGood = trendCfg.backgroundGood || '#E6F4EA';
  const bgBad = trendCfg.backgroundBad || '#FCE8E8';
  const txtGood = trendCfg.textGood || '#137333';
  const txtBad = trendCfg.textBad || '#A50E0E';
  const thresholdsByIndex = trendCfg.thresholdsByMetricIndex || {};

  let trendMetricIndex = -1;
  schema.columns.forEach((col, i) => {
    if (!col.trend) return;

    trendMetricIndex += 1;
    const threshold = thresholdsByIndex[trendMetricIndex] !== undefined
      ? thresholdsByIndex[trendMetricIndex]
      : 0.01;

    const sheetCol = startCol + i;
    const range = sheet.getRange(startRow, sheetCol, endRow - startRow + 1, 1);
    const firstCell = a1_(startRow, sheetCol);

    const isNumeric = `ISNUMBER(${firstCell})`;

    const goodFormula = col.direction === 'lower_better'
      ? `=AND(${isNumeric},${firstCell}<=-${threshold})`
      : `=AND(${isNumeric},${firstCell}>=${threshold})`;

    const badFormula = col.direction === 'lower_better'
      ? `=AND(${isNumeric},${firstCell}>=${threshold})`
      : `=AND(${isNumeric},${firstCell}<=-${threshold})`;

    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(goodFormula)
        .setBackground(bgGood)
        .setFontColor(txtGood)
        .setRanges([range])
        .build()
    );

    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied(badFormula)
        .setBackground(bgBad)
        .setFontColor(txtBad)
        .setRanges([range])
        .build()
    );
  });

  return rules;
}

/* ====== 5) Data coercion ====== */

function coerceNumericColumns_(sheet, schema, startRow, endRow) {
  if (endRow < startRow) return;

  const startCol = schema.tableStartColumn;

  // Identify numeric columns by schema format (exclude text)
  const numericColOffsets = schema.columns
    .map((c, idx) => ({ c, idx }))
    .filter(({ c }) => (c.format || '') !== 'text')
    .map(({ idx }) => idx);

  // Pull each numeric column individually to reduce accidental edits on text columns.
  numericColOffsets.forEach((offset) => {
    const sheetCol = startCol + offset;
    const range = sheet.getRange(startRow, sheetCol, endRow - startRow + 1, 1);
    const values = range.getValues();

    let changed = false;

    for (let r = 0; r < values.length; r++) {
      const v = values[r][0];
      if (typeof v !== 'string') continue;

      const s = v.trim();
      if (s === '') continue;

      // Percent like "12.3%" → 0.123
      if (s.endsWith('%')) {
        const num = parseFloat(s.slice(0, -1));
        if (!Number.isNaN(num)) {
          values[r][0] = num / 100;
          changed = true;
        }
        continue;
      }

      // Plain numeric string
      const num = parseFloat(s);
      if (!Number.isNaN(num)) {
        values[r][0] = num;
        changed = true;
      }
    }

    if (changed) range.setValues(values);
  });
}

/* ====== 6) Schema + helpers ====== */

function getSchema_() {
  if (!RANKING_FORMATTING_SCHEMA_JSON || !RANKING_FORMATTING_SCHEMA_JSON.trim()) {
    throw new Error(
      'Missing schema JSON. Paste the contents of ranking_formatting_schema.json into RANKING_FORMATTING_SCHEMA_JSON.'
    );
  }

  const schema = JSON.parse(RANKING_FORMATTING_SCHEMA_JSON);

  // Minimal validation
  if (!schema.sheetName || !schema.headerRow || !schema.tableStartColumn || !schema.columns) {
    throw new Error('Schema JSON is missing required fields.');
  }

  return schema;
}

function findLastNonEmptyRowInColumn_(sheet, col, startRow) {
  const lastRow = sheet.getLastRow();
  if (lastRow < startRow) return startRow;

  const values = sheet.getRange(startRow, col, lastRow - startRow + 1, 1).getValues();

  for (let i = values.length - 1; i >= 0; i--) {
    const v = values[i][0];
    if (v !== '' && v !== null) return startRow + i;
  }

  return startRow;
}

function a1_(row, col) {
  return `${colToLetter_(col)}${row}`;
}

function colToLetter_(column) {
  let temp;
  let letter = '';
  let col = column;

  while (col > 0) {
    temp = (col - 1) % 26;
    letter = String.fromCharCode(temp + 65) + letter;
    col = (col - temp - 1) / 26;
  }

  return letter;
}
